{
  "hash": "79f9a089aee08a2c0fa8eb7a27924881",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Basic Python Programming\"\ndate: 2024-12-26\ndescription: \"Basics of Python Programming.\"\nauthor: \"Isaac Quintanilla Salinas\"\ndraft: false\neditor: source\ncategories: \n  - r2py\nimage: \"test.jpg\"\nknitr:\n  opts_chunk: \n    echo: true\n    message: false\n    warning: false\n---\n\n\n\n## Introduction\n\nWhen writing this post, I realize how difficult it will be for me to create a comprehensive tutorial about Python. There are things I learned along the way that makes it easier for me to pick up Python from programming in R, and most importantly c++. For example, Python's indexing begins with 0 instead of 1, python does not uses braces for code blocks, or how functions can be applied to objects. This makes it easier for me to learn programming in python. However, I certainly struggled with these topics when first learning about it, but I managed to learn it. And I believe anyone can as well.\n\n\nMost of the material I talk about can be found in Wes McKinney's [Python for Data Analysis](https://wesmckinney.com/book/); specifically, in Chapter 2, 3, and 4.\n\n\n### Loaded Modules\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport math\nimport numpy as np\n```\n:::\n\n\n\n## Python as a calculator\n\nThis is almost a direct copy of my own tutorial written in R. Notice how several of the commands you learned in R also work in Python, with some slight deviations.\n\n\n### Calculator\n\nThis section focuses on the basic calculation that can be done in R. This is done by using different operators in Python. The table below provides some of the basic operators Python can use:\n\n| Operator    | Description        |\n|:------------|:-------------------|\n| `+`         | Addition           |\n| `-`         | Subtraction        |\n| `*`         | Multiplication     |\n| `/`         | Divides            |\n| `**`        | Exponentiate       |\n| `?`         | Help Documentation |\n\n\n#### Addition\n\nTo add numbers in R, all you need to use the `+` operator. For example $2 + 2 = 4$. When you type it in R you have:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n2 + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n4\n```\n\n\n:::\n:::\n\n\n\nWhen you ask R to perform a task, it prints out the result of the task. As we can see above, R prints out the number 4.\n\nTo add more than 2 numbers, you can simply just type it in.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n2 + 2 + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n6\n```\n\n\n:::\n:::\n\n\n\nThis provides the number 6.\n\n#### Subtraction\n\nTo subtract numbers, you need to use the `-` operator. Try `4 - 2`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n4 - 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2\n```\n\n\n:::\n:::\n\n\n\nTry `4 - 6 - 4`\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n4 - 6 - 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n-6\n```\n\n\n:::\n:::\n\n\n\nNotice that you get a negative number.\n\nNow try `4 + 4 - 2 + 8`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n4 + 4 - 2 + 8\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n14\n```\n\n\n:::\n:::\n\n\n\n#### Multiplication\n\nTo multiply numbers, you will need to use the `*` operator. Try `4 * 4`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n4 * 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n16\n```\n\n\n:::\n:::\n\n\n\n#### Division\n\nTo divide numbers, you can use the `/` operator. Try `9 / 3`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n9 / 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3.0\n```\n\n\n:::\n:::\n\n\n\n#### Exponents\n\nTo exponentiate a number to the power of another number, you can use the `**` operator. Try `2**5`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n2**5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n32\n```\n\n\n:::\n:::\n\n\n\n\n#### Roots\n\nTo take the n-th root of a value, use the `**` operator with the `/` operator to take the n-th root. For example, to take $\\sqrt[5]{35}$, type `32**(1/5)`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n32**(1/5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2.0\n```\n\n\n:::\n:::\n\n\n\n#### Logarithms\n\nWe will use the `math` module for mathematical functions:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport math\n```\n:::\n\n\n\nTo take the natural logarithm of a value, you will use the `math.log()` function. Try `math.log(5)`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmath.log(5, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0.6989700043360187\n```\n\n\n:::\n:::\n\n\n\nIf you want to take the logarithm of a different base, you will use the `math.log(X, Y)`, where `X` is the number you wish to take the logarithm and `Y` is the base of the log^[I tried to type the argument `Base=` but did not work].\n\n\nIf you want to find $e^5$, you will use the `math.exp()` function. Try `math.exp(2)`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmath.exp(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n7.38905609893065\n```\n\n\n:::\n:::\n\n\n\n\n### Comparing Numbers {#sec-comparing-numbers}\n\nAnother important part of R is comparing numbers. When you compare two numbers, R will tell if the statement is `True` or `False`. Below are the different comparisons you can make:\n\n| Operator | Description           |\n|----------|-----------------------|\n| `>`      | Greater Than          |\n| `<`      | Less Than             |\n| `>=`     | Greater than or equal |\n| `<=`     | Less than or equal    |\n| `==`     | Equals                |\n| `!=`     | Not Equals            |\n\n#### Less than/Greater than\n\nTo check if one number is less than or greater than another number, you will use the `>` or `<` operators. Try `5 > 4`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n5 > 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue\n```\n\n\n:::\n:::\n\n\n\nNotice that R states it's true. It evaluates the expression and tells you if it's true or not. Try `5 < 4`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n5 < 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFalse\n```\n\n\n:::\n:::\n\n\n\nNotice that R tells you it is false.\n\n#### Less than or equal to/Greater than or equal to\n\nTo check if one number is less than or equal to/greater than or equal to another number, you will use the `>=` or `<=` operators. Try `5 >= 5`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n5 >= 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue\n```\n\n\n:::\n:::\n\n\n\nTry `5 >= 4`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n5 >= 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue\n```\n\n\n:::\n:::\n\n\n\nTry `5 <= 4`\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n5 <= 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFalse\n```\n\n\n:::\n:::\n\n\n\n#### Equals and Not Equals\n\nTo check if 2 numbers are equal to each other, you can use the `==` operator. Try `3 == 3`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n3 == 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue\n```\n\n\n:::\n:::\n\n\n\nTry `4 == 3`\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n3 == 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFalse\n```\n\n\n:::\n:::\n\n\n\nAnother way to see if 2 numbers are not equal to each other, you can use the `!=`. Try `3 != 4`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n3 != 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue\n```\n\n\n:::\n:::\n\n\n\nTry `3 != 3`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n3 != 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFalse\n```\n\n\n:::\n:::\n\n\n\nYou may be asking why use `!=` instead of `==`. They both provides similar results. Well the reason is that you may need the `True` output for analysis. One is only true when they are equal, while the other is true when they are not equal.\n\nIn general, the `!` operator means not or opposite. It can be used to change an `True` to a `False` and vice-versa.\n\n## Modules and Functions\n\nAs I am learning \n\n## Tuples and Lists\n\nAfter getting a handle of python with basic computations and basic modules, my next urging was to create a vector in the same way that I do it in R. After researching around, I noticed that Python had these vector-like objects called Tuple and Lists. The main differenece is that Tuples are immutable (cannot alter) and Lists are mutable (can alter). \n\nTo create a Tuple, we name an object, use the `=` sign, list a set of values (seperated by commas), and surround the lists by paranthesis `()`.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\na = (1, 2, 3, 4, 5)\n```\n:::\n\n\n\nTo create a List, we follow the same format as a Tuple, but change the paranthesis to square brackets:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nb = [1, 2, 3, 4, 5]\n```\n:::\n\n\n\n\nNow if you try to perform an operation to a Tuple or List, you will get an error:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\na+5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTypeError: can only concatenate tuple (not \"int\") to tuple\n```\n\n\n:::\n\n```{.python .cell-code}\nb+8\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTypeError: can only concatenate list (not \"int\") to list\n```\n\n\n:::\n:::\n\n\n\nOther operations may lead to other things:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\na*5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5)\n```\n\n\n:::\n\n```{.python .cell-code}\nb*5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\n```\n\n\n:::\n:::\n\n\n\nAs you can see, you cannot treat this as the traditional vector from R, this has lead me to look at arrays from Numpy.\n\n## Numpy\n\nNumpy, or Numerical Python, is a Python module used for scientific computing. From what I can tell, you conduct computational tasks on a Numpy array. This makes me think that Numpy is closest to vector a matrix operations from R.\n\n### Create a Numpy Array\n\nTo create a numpy array, we will input a list into the function `np.array`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nc = np.array([1,2,3,4,5])\n```\n:::\n\n\n\nPrinting out `c` will display the array:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([1, 2, 3, 4, 5])\n```\n\n\n:::\n:::\n\n\n\nWe can do some basic operations on the array:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nc + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([3, 4, 5, 6, 7])\n```\n\n\n:::\n\n```{.python .cell-code}\nc/2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([0.5, 1. , 1.5, 2. , 2.5])\n```\n\n\n:::\n\n```{.python .cell-code}\nc*2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([ 2,  4,  6,  8, 10])\n```\n\n\n:::\n:::\n\n\n\n\nAdditionally, we can apply basic functions to the object `c`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nc.shape\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(5,)\n```\n\n\n:::\n\n```{.python .cell-code}\nc.mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnp.float64(3.0)\n```\n\n\n:::\n\n```{.python .cell-code}\nc.sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnp.int64(15)\n```\n\n\n:::\n\n```{.python .cell-code}\nnp.median(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnp.float64(3.0)\n```\n\n\n:::\n\n```{.python .cell-code}\nc.sum() + 8\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnp.int64(23)\n```\n\n\n:::\n:::\n\n\n\nNotice how some functions, like `shape`, and be provided after the object (seperated by a period) without paranthesis. Other objects need the paranthesis to be executed.\n\n### Indexing a Numpy Array\n\nWe can index the array `c` using the square brackets on the object:\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nc[0]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnp.int64(1)\n```\n\n\n:::\n\n```{.python .cell-code}\nc[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnp.int64(3)\n```\n\n\n:::\n\n```{.python .cell-code}\nc[0:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([1, 2])\n```\n\n\n:::\n\n```{.python .cell-code}\nc[0:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([1, 2, 3])\n```\n\n\n:::\n:::\n\n\n\nFor the code block above, we notice a few things. First is that indexing stats with 0. Second, when we are indexing sequential values using the `:` operator^[The same as R.], it does not return the last element indicated on the right of the colon.\n\nNow, let's create a new array called `d` which is a subset of `c[0:3]`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nd = c[0:3]\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([1, 2, 3])\n```\n\n\n:::\n:::\n\n\n\nWe have a new array with the first 3 elements. Now let's change the second value of `d` to 909.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nd[1] = 909\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([  1, 909,   3])\n```\n\n\n:::\n:::\n\n\n\nIt goes as expected. Let's print out `c`:\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([  1, 909,   3,   4,   5])\n```\n\n\n:::\n:::\n\n\n\nNotice how `c` now contains the value 909, even though that `d` was the only one changed. This is because Python creates the object, and the names of those objects (`c` and `d`) point and/or transform that object as necessary. Any changes to one named object will change the overall object. It does not create a new object like in R.\n\nAfter I learned this, I did not know how I feel about this. I personally liked the R's way to copy and paste objects, which allowed me to manipulate something without having to worry about changing the original. After some thinking, I don't think I liked it, but that could be because I am stuck in my ways. There may be some advantages on how Python treats objects, but as of right now, I do not know.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}